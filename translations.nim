import karax / [kdom, jstrutils, kajax, vdom, jjson, karaxdsl,karax, vstyles,i18n, languages,kbase]

proc textContent*(e: Element): cstring {.
  importcpp: "#.textContent", nodecl.}

proc textContent*(e: Node): cstring {.
  importcpp: "#.textContent", nodecl.}

proc zhCN*(e:Event,n:VNode) =
    setCurrentLanguage(Language.zhCN)

proc enUS*(e:Event,n:VNode) =
    setCurrentLanguage(Language.enUS)

proc t*(text: kstring): cstring =
    i18n($text).cstring

var dict: seq[(string,string)]
dict = @[
  ("Nim Tutorial (Part I)", "Nim中文教程（第一部分）"),
  ("Manual", "手册"),
  ("Index", "索引"),
  ("Search: ", "搜索："),
  ("Standard library", "标准库"),
  ("Introduction", "序"),
  ("The first program", "第一个程序"),
  ("Lexical elements", "词汇元素"),
  ("String and character literals", "字符串和字符字面值"),
  ("Comments", "注释"),
  ("Numbers", "数字"),
  ("The var statement", "var语句"),
  ("The assignment statement", "赋值语句"),
  ("Constants", "常量"),
  ("The let statement", "let语句"),
  ("Control flow statements", "控制流语句"),
  ("If statement", "If语句"),
  ("Case statement", "Case语句"),
  ("While statement", "While语句"),
  ("For statement", "For语句"),
  ("Scopes and the block statement", "作用域和块语句"),
  ("Break statement", "Break语句"),
  ("Continue statement", "Continue语句"),
  ("When statement", "When语句"),
  ("Statements and indentation", "语句和缩进"),
  ("Procedures", "过程"),
  ("Result variable", "Result变量"),
  ("Parameters", "形参"),
  ("Discard statement", "Discard语句"),
  ("Named arguments", "命名形参"),
  ("Default arguments", "默认形参"),
  ("Overloaded procedures", "过程重载"),
  ("Operators", "运算符"),
  ("Forward declarations", "前向声明"),
  ("Iterators", "迭代器"),
  ("Basic types", "基本类型"),
  ("Booleans", "布尔"),
  ("Characters", "字符"),
  ("Strings", "字符串"),
  ("Integers", "整型"),
  ("Floats", "浮点"),
  ("Type Conversion", "类型转换"),
  ("Internal type representation", "内部类型表示"),
  ("Advanced types", "高级类型"),
  ("Enumerations", "枚举"),
  ("Ordinal types", "序数类型"),
  ("Subranges", "子范围"),
  ("Sets", "集合"),
  ("Bit fields", "位字段"),
  ("Arrays", "数组"),
  ("Sequences", "序列"),
  ("Open arrays", "开放数组"),
  ("Varargs", "可变形参"),
  ("Slices", "切片"),
  ("Objects", "对象"),
  ("Tuples", "元组"),
  ("Reference and pointer types", "引用和指针类型"),
  ("Procedural type", "过程类型"),
  ("Distinct type", "Distinct类型"),
  ("Modules", "模块"),
  ("Excluding symbols", "排除符号"),
  ("From statement", "From语句"),
  ("Include statement", "Include语句"),
  ("Part 2", "第二部分"),
  ("Author:", "作者："),
  ("Version:", "版本："),
  ("\"Der Mensch ist doch ein Augentier -- sch\xC3\xB6ne Dinge w\xC3\xBCnsch ich mir.\" ", "人是视觉动物——我渴望美好事物。"),
  ("This document is a tutorial for the programming language ", "本文档是编程语言"),
  (". This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The ", 
  "的教程。本教程认为你熟悉基本的编程概念如变量、类型或语句。"),
  ("manual","手册"),
  ("contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim\'s documentation, follow the ",
  "有更多高级语言特性示例。教程代码示例和其余Nim文档遵循"),
  ("Nim style guide","Nim风格指南"),
  ("The first program","第一个程序"),
  ("We start the tour with a modified \"hello world\" program:","我们用\"hello world\"程序开启教程之旅："),
  ("# This is a comment","# 这里是注释"),
  ("Save this code to the file \"greetings.nim\". Now compile and run it: ","代码保存到\"greetings.nim\"，编译运行:"),
  ("With the ","用"),
  ("switch","开关"),
  ("Nim executes the file automatically after compilation. You can give your program command line arguments by appending them after the filename: ",
  "Nim编译后自动执行文件。可以在文件名后加上程序的命令行参数："),
  ("Commonly used commands and switches have abbreviations, so you can also use: ","常用命令和开关有简写，所以也可以用："),
  ("To compile a release version use: ","编译发布版本使用："),
  ("By default the Nim compiler generates a large amount of runtime checks aiming for your debugging pleasure. With ",
  "为了方便调试，Nim编译器默认生成大量运行时检查。用"),
  ("some checks are ","一些检查"),
  ("turned off and optimizations are turned on","被关闭并启用优化"),
  ("Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim\'s way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.",
  "程序一目了然：没有缩进的语句在程序开始时执行。缩进是Nim划分语句的方式。缩进只能使用空格，不允许制表符。"),
  ("String literals are enclosed in double quotes. The ","字符串字面值用双引号括起来。"),
  ("statement declares a new variable named ","语句声明一个新的变量，名叫"),
  ("of type ","，属于"),
  ("with the value that is returned by the ","，值为被"),
  ("procedure. Since the compiler knows that ","过程返回的值。因为编译器知道"),
  ("returns a string, you can leave out the type in the declaration (this is called ","返回字符串，可以在声明中不写类型（这叫做"),
  ("local type inference","局部类型推导"),
  ("). So this will work too:","）。所以这也可以："),
  ("Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.",
  "这基本是Nim中存在的唯一形式的类型推导：兼顾简洁和可读。"),
  ("The \"hello world\" program contains several identifiers that are already known to the compiler: ",
  "\"hello world\"程序包含几个编译器已知的标识符："),
  (", etc. These built-ins are declared in the ","等。这些内置类型声明在"),
  ("module which is implicitly imported by any other module.","模块，其通过任意其它模块隐式导入。"),
  ("Let us look at Nim\'s lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.",
  "我们来看下Nim的词汇元素的更多细节：和其它编程语言一样，Nim由（字符串）字面值、标识符、关键字、注释、运算符和其它标点符号构成。"),
  ("String literals are enclosed in double quotes; character literals in single quotes. Special characters are escaped with ",
  "字符串字面值括在双引号中；字符字面值在单引号中。特殊符号转义用"),
  ("means newline, ","意为换行"),
  ("means tabulator, etc. There are also ","意为制表符等。还有"),
  ("raw","原始"),
  ("string literals:","字符串字面值："),
  ("In raw literals the backslash is not an escape character.","原始字面值中的反斜杠不是转义字符。"),
  ("The third and last way to write string literals are ","第三个也是最后一种写字符串字面值的方法是"),
  ("long string literals","长字符串字面值"),
  (". They are written with three quotes: ","。用三引号写："),
  ("; they can span over multiple lines and the ","可以跨越多行并且"),
  ("is not an escape character either. They are very useful for embedding HTML code templates for example.","也不是转义字符。这对于例如嵌入HTML代码模板非常有用。"),
  ("Comments start anywhere outside a string or character literal with the hash character ","注释以字符串或字符字面值外的哈希字符开始"),
  (". Documentation comments start with ","。文档注释用"),
  ("## a documentation comment","## 文档注释"),
  ("Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree! This feature enables simpler documentation generators.",
  "文档注释是符号，属于语法树，只允许出现在输入文件中的特定位置。这允许更简单的文档生成器。"),
  ("Multiline comments are started with ","多行注释用"),
  ("and terminated with ","结束用"),
  (". Multiline comments can also be nested.","。多行注释可以嵌套。"),
  ("#[\x0AYou can have any Nim code text commented\x0Aout inside this with no indentation restrictions. yes(\"May I ask a pointless question?\") #[ Note: these can be nested!! ]#\x0A]#",
  "#[\x0A你可以在这里注释任何Nim代码文本\x0A没有缩进限制。 yes(\"May I ask a pointless question?\") #[ 注意: 这些可以嵌套。 ]#\x0A]#"),
  ("Numerical literals are written as in most other languages. As a special twist, underscores are allowed for better readability: ",
  "数字字面值和大多数其它语言一样。用下划线做特殊调整以获取更好的可读性："),
  ("(one million). A number that contains a dot (or \'e\' or \'E\') is a floating point literal: ",
  "(一百万)。 包含点 (或 \'e\' 或 \'E\') 的数字是浮点字面值:"),
  ("(one billion). Hexadecimal literals are prefixed with ","(十亿)。 十六进制字面值前缀用"),
  (", binary literals with ","二进制用"),
  ("and octal literals with ","八进制用"),
  (". A leading zero alone does not produce an octal.","。只有开头零的不是八进制。"),
  ("The var statement declares a new local or global variable:","var语句声明一个新的本地或全局变量："),
  ("# declares x and y to have the type ``int``","# 声明x和y，具有类型``int``"),
  ("Indentation can be used after the ","缩进可用在"),
  ("keyword to list a whole section of variables:","关键字后来罗列一个变量段："),
  ("# a comment can occur here too","# 注释也可以在这里"),
  ("The assignment statement assigns a new value to a variable or more generally to a storage location:",
  "赋值语句给变量或者说是更普遍的存储地址赋新值："),
  ("# introduces a new variable `x` and assigns a value to it",
  "# 引入一个新变量`x`并赋值给它"),
  ("# assigns a new value to `x`","# 赋新值给`x`"),
  ("is the ","是"),
  ("assignment operator","赋值操作符"),
  (". The assignment operator can be overloaded. You can declare multiple variables with a single assignment statement and all the variables will have the same value:",
  "。赋值运算符可以重载。你可以用一个赋值语句声明多个变量，所有变量有同样的值："),
  ("# assigns 3 to the variables `x` and `y`",
  "给变量`x`和`y`赋值为3"),
  ("# outputs \"x 3\"","# 输出 \"x 3\""),
  ("# changes `x` to 42 without changing `y`","# 不改变`y`，把`x`变为42"),
  ("# outputs \"x 42\"","# 输出 \"x 42\""),
  ("# outputs \"y 3\"","# 输出 \"y 3\""),
  ("Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will ",
  "注意用一个调用过程的赋值语句声明多个变量可能会有意外结果：编译器会"),
  ("unroll","展开"),
  ("the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! "&
  "For safety use side-effect free procedures if making multiple assignments.",
  "赋值并多次调用过程。如果过程结果取决于副作用，变量可能有不一样的值。为了安全考虑，如果要用多赋值，使用不含副作用的过程。"),
("Constants are symbols which are bound to a value. The constant\'s value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time:",
"常量是绑定了值的符号。常量值不可改变。编译器必需能够在编译期对表达式求值："),
("# the constant x contains the string \"abc\"","# 常量x包含\"abc\"字符串"),
("keyword to list a whole section of constants:","关键字后用来罗列常量段："),
("# computations are possible","# 计算是可能的"),
("statement works like the ","语句的作用类似"),
("statement but the declared symbols are ","语句但声明的符号是"),
("single assignment","单赋值"),
("variables: After the initialization their value cannot change:","变量：它们值在初始化后不可改变："),
("# introduces a new variable `x` and binds a value to it","# 引入新变量`x`并绑定一个值"),
("# Illegal: assignment to `x`","# 无效：赋值给`x`"),
("and ","和"),
("is: ","是："),
("introduces a variable that can not be re-assigned, ","引入不可再赋值的变量"),
("means \"enforce compile time evaluation and put it into a data section\":",
"意味着\"强制编译期并放入数据段\"："),
("# Error: constant expression expected","# 错误：需要常量表达式"),
("# works","# 正常"),
("The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.",
"问候程序由三个顺序执行语句组成。只有最原始的程序可以免于分支和循环。"),
("The if statement is one way to branch the control flow:","if语句是创建控制流分支的一种方法："),
("There can be zero or more ","可以没有或多个"),
("parts, and the ","部分，并且"),
("part is optional. The keyword ","部分是可选的，关键字"),
("is short for ","是"),
(", and is useful to avoid excessive indentation. (The ","的缩写，用于避免过度缩进。"),
("is the empty string. It contains no characters.)","是空字符串。不包含字符。"),
("Another way to branch is provided by the case statement. A case statement is a multi-branch:",
"另一种创建分支的方法是case语句。case语句具有多个分支："),
("As it can be seen, for an ","可以看到，对于一个"),
("branch a comma separated list of values is also allowed.","分支，逗号分隔的值列表也是允许的。"),
("The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:",
"case语句可以处理整型，其它序数类型和字符串。（序数类型将在后面解释。）对于整型或其它序数类型还可以使用范围："),
("# this statement will be explained later:","# 这个语句将在后面解释："),
("However, the above code does not compile: the reason is that you have to cover every value that ",
"上面的代码无法编译：原因是必需覆盖每个值"),
("may contain, but the code only handles the values ","可能含有的值，但代码只处理"),
(". Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:",
"。因为列出来其它可能的值不是非常实际（尽管范围标记可以），告诉编译器不处理其它值即可："),
("The empty ","空"),
("is a ","是"),
("do nothing","什么都不做"),
("statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an ",
"语句。编译器知道带有else部分的case语句不会出错，错误就此消除。注意不可能覆盖所有可能的字符串值：这是为什么字符串情况总需要"),
("branch.","分支"),
("In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.",
"通常case语句用于子范围类型或枚举，编译器检查覆盖任何可能值帮助很大。"),
("The while statement is a simple looping construct:","while语句是一个简单的循环构造："),
("# no ``var``, because we do not declare a new variable here","# 没有``var``,因为我们没有声明新变量"),
("The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).",
"示例用while循环持续询问用户他们的名字，只要用户不输入（只按回车键）。"),
("statement is a construct to loop over any element an ","语句是一个构造，循环的任意元素由"),
("iterator","迭代器"),
("provides. The example uses the built-in ","提供。示例使用内置"),
("iterator:","迭代器："),
("The variable ","变量"),
("is implicitly declared by the ","隐式声明通过"),
("loop and has the type ","循环并具有类型"),
(", because that is what ","，因为这是"),
("returns. ","返回的"),
("runs through the values 1, 2, .., 10. Each value is ","遍历值1,2, ..,10。每个值被"),
("-ed. This code does the same:" ,"打印。下面代码功能相同"),
("Counting down can be achieved as easily (but is less often needed):" ,"倒数可以很容易做到(但不常用)："),
("Since counting up occurs so often in programs, Nim also has a " ,"因为正数在程序中比较常见，Nim也有"),
("iterator that does the same:" ,"相同功能的迭代器："),
("Zero-indexed counting have two shortcuts " ,"零索引计数有两个快捷方式"),
("to simplify counting to one less than the higher index:" ,"简化计数到索引的前一个位置："),
("Other useful iterators for collections (like arrays and sequences) are" ,"其它有用迭代器（如数组和序列）有"),
(", which provides immutable and mutable elements respectively, and" ,"，分别提供不可变和可变元素，还有"),
("which provides the element and an index number (immutable and mutable respectively)" ,
"分别提供可变和不可变的元素和索引数"),
("Control flow statements have a feature not covered yet: they open a new scope. This means that in the following example, " ,
"控制流语句还有个没有覆盖的特性：它们创建新的作用域。这意味着在下列示例中，"),
("is not accessible outside the loop:" ,"在循环外不可访问："),
("A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The " ,
"while(for)语句引入一个隐式块。标识符只在声明的块中可见。"),
("statement can be used to open a new block explicitly:" ,"语句可以用于显式创建新块："),
("# does not work either" ,"# 不对"),
("The block's " ,"块的"),
("in the example) is optional." ,"示例中）是可选的。"),
("A block can be left prematurely with a ","跳出块可以用"),
("statement. The break statement can leave a ","语句。break语句可以跳出"),
(", or a ","或者"),
("statement. It leaves the innermost construct, unless a label of a block is given:",
"语句。它跳出最内层的构造，除非给定块标签"),
("# leaves the loop, but not the block","# 跳出循环，但没有跳出块"),
("Like in many other programming languages, a ","像在许多其它编程语言，"),
("statement starts the next iteration immediately:","语句立刻开始下一个迭代："),
("Example:","示例："),
("statement is almost identical to the ","语句几乎等价于"),
("statement, but with these differences:","语句，但又不同："),
("Each condition must be a constant expression since it is evaluated by the compiler.",
"每个条件必须是常量表达式，因为编译器要对它求值。"),
("The statements within a branch do not open a new scope.","分支中的语句不创建新作用域。"),
("The compiler checks the semantics and produces code ","编译器检查语义并"),
("only","只"),
("for the statements that belong to the first condition that evaluates to ","为第一个语句生成代码，当其所属条件求值为"),
(". ","。"),
("statement is useful for writing platform specific code, similar to the ",
"语句对写平台特定代码很有用，类似于"),
("construct in the C programming language.",
"C编程语言构造"),
("Now that we covered the basic control flow statements, let's return to Nim indentation rules.",
"既然我们过完了基础的控制流语句，让我们回到Nim缩进规则。"),
("In Nim there is a distinction between ",
"Nim中有区分在"),
("simple statements","简单语句"),
("complex statements","复杂语句"),
("Simple statements","简单语句"),
("cannot contain other statements: Assignment, procedure calls or the ",
"不能包含其它语句：赋值、过程调用或"),
("statement belong to the simple statements. ","语句，它属于简单语句。"),
("Complex statements","复杂语句"),
("like ","像"),
("can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:",
"可以包含其它语句。为了避免歧义，复杂语句必须缩进，单个简单语句不需要："),
("# no indentation needed for single assignment statement:","# 单个赋值语句不需要缩进"),
("# indentation needed for nested if statement:","# 嵌套if语句需要缩进："),
("# indentation needed, because two statements follow the condition:","# 需要缩进，因为两个语句在条件之后："),
("Expressions","表达式"),
("are parts of a statement which usually result in a value. The condition in an if statement is an example for an expression. Expressions can contain indentation at certain places for better readability:",
"是通常结果为一个值的语句部分。if语句中的条件是一种表达式。表达式可以在特定的地方缩进以具有更好的可读性。"),
("As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.",
"一般来说，表达式中的缩进允许在运算符、开放的小括号和逗号后。"),
("With parenthesis and semicolons ","用小括号和分号"),
("you can use statements where only an expression is allowed:",
"你可以在只允许表达式的地方使用语句："),
("# computes fac(4) at compile time:","# 编译期计算fac(4)："),
("To define new commands like ","为了定义一个新命令如"),
("in the examples, the concept of a ","如在示例中，概念"),
("procedure","过程"),
("is needed. (Some languages call them ","是必要的。（一些语句叫做"),
("methods","方法"),
("functions","函数"),
(".) In Nim new procedures are defined with the ","。）Nim中新方法定义用"),
("keyword:","关键字:"),
("This example shows a procedure named ","示例展示了一个过程，叫"),
("that asks the user a ","询问用户"),
("and returns true if they answered \"yes\" (or something similar) and returns false if they answered \"no\" (or something similar). A ",
"并返回true如果回答\"yes\"（或类似的），返回false如果回答\"no\"或类似的）。"),
("statement leaves the procedure (and therefore the while loop) immediately. The ",
"语句立刻离开过程(因此也离开了while循环)。"),
("syntax describes that the procedure expects a parameter named ","语法描述过程需要一个参数，名叫"),
("and returns a value of type ","并返回一个值类型为"),
("type is built-in: the only valid values for ","类型为内置：有效"),
("are ","为"),
(". The conditions in if or while statements must be of type ",
"。if或while语句中的条件必须属于类型"),
("Some terminology: in the example ","一些术语：在示例中"),
("is called a (formal) ","叫做形"),
("parameter","参"),
("is called an ","叫做"),
("argument","实参"),
("that is passed to this parameter.","，传递给这个参数。"),
("A procedure that returns a value has an implicit ","返回值的过程声明一个隐式的"),
("variable declared that represents the return value. A ","变量，代表返回值。"),
("statement with no expression is a shorthand for ","没有表达式的语句简化了"),
(". The ","。"),
("value is always returned automatically at the end of a procedure if there is no ",
"值总是在过程的结束前自动返回如果没有"),
("statement at the exit.","语句。"),
("variable is already implicitly declared at the start of the function, so declaring it again with \'var result\', for example, "&
"would shadow it with a normal variable of the same name. The result variable is also already initialised with the type\'s default value. Note that referential data types will be ",
"变量已经隐式声明在函数的开关，例如所以如果再次声明\'var result\'，一个同名的普通变量会隐藏它。result变量也已经被类型的默认值初始化。注意引用数据类型将是"),
("at the start of the procedure, and thus may require manual initialisation. ","在过程的开头，因此需要手动初始化。"),
("Parameters are immutable in the procedure body. By default, their value cannot be changed because this allows the compiler to implement parameter passing in the most efficient way. If a mutable variable is needed inside the procedure, it has to be declared with ",
"参数在过程体中不可修改。默认地，他们的值不能改变因为这允许编译器实现高效的参数传递。如果过程内需要可变变量，它必需声明为"),
("in the procedure body. Shadowing the parameter name is possible, and actually an idiom:","在过程体中。隐藏参数名是可能的，实际上这是一个习惯："),
("If the procedure needs to modify the argument for the caller, a ","如果过程需要为调用者修改实参，"),
("parameter can be used:","形参可以实现："),
("# integer division","# 整数除法"),
("# integer modulo operation","# 整数取模运算"),
("# modifies x and y","# 修改x和y"),
("In the example, ","示例中，"),
("var parameters","var形参"),
(". Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.",
"。var形参可以被过程修改并且这些变化对调用者可见。注意上面的示例可以更好的利用元组作为返回值代替var形参。"),
("To call a procedure that returns a value just for its side effects and ignoring its return value, a ","只为副作用调用返回值的过程并忽略返回值，"),
("statement ","语句"),
("must","必须"),
("be used. Nim does not allow silently throwing away a return value:","使用。Nim不允许静默丢弃返回值："),
("The return value can be ignored implicitly if the called proc/iterator has been declared with the ",
"返回值可以被隐式忽略如果一个被调用的过程或迭代器声明为"),
("pragma:","编译指示："),
("# now valid","# 现在可以了"),
("The ",""),
("statement can also be used to create block comments as described in the ",
"也可以用于创建块注释，描述在"),
("section.","部分。"),
("Often a procedure has many parameters and it is not clear in which order the parameters appear. This is especially true for procedures that construct a complex data type. "&
"Therefore the arguments to a procedure can be named, so that it is clear which argument belongs to which parameter:",
"过程通常有多个形参，形参出现的顺序并不清楚。这对构造复杂的数据类型尤其适用。因此过程可以命名实参，以便于清楚地看到哪个实参属于哪个形参："),
("Now that we use named arguments to call ","既然我们使用命名实参调用"),
("the argument order does not matter anymore. Mixing named arguments with ordered arguments is also possible, but not very readable:",
"实参顺序不再重要。把有序实参和命名实参混合起来是可以的，但不是非常可读："),
("The compiler checks that each parameter receives exactly one argument.","编译器检查每个形参只收到一个实参。"),
("To make the ","为了使"),
("proc easier to use it should provide ","proc更易于使用，应当提供"),
("default values","默认值"),
("; these are values that are used as arguments if the caller does not specify them:",
";这些是如果调用者没有指定而作为实参使用的值："),
("Now the call to ","现在调用"),
("only needs to set the values that differ from the defaults.","只需要设置不同于默认值的实参值。"),
("Note that type inference works for parameters with default values; there is no need to write ",
"注意类型推导适用于默认值；不需要写"),
(", for example. ","，例如。"),
("Nim provides the ability to overload procedures similar to C++:","Nim提供类似C++的过程重载："),
("# calls the toString(x: int) proc","# 调用toString(x: int) proc"),
("# calls the toString(x: bool) proc","# 调用toString(x: bool) proc"),
("(Note that ","(注意"),
("is usually the ","通常是"),
("operator in Nim.) The compiler chooses the most appropriate proc for the ","运算符在Nim中。）编译器选择最合适的过程"),
("calls. How this overloading resolution algorithm works exactly is not discussed here (it will be specified in the manual soon). "&
"However, it does not lead to nasty surprises and is based on a quite simple unification algorithm. Ambiguous calls are reported as errors.",
"调用。这种重载解析算法的工作原理不在这里讨论(将在手册中具体说明)。但它基于一个简单的统一算法，不会节外生枝，歧义调用将报错。"),
("The Nim library makes heavy use of overloading - one reason for this is that each operator like ",
"Nim库重度使用重载- 一个原因是每个运算符如"),
("is just an overloaded proc. The parser lets you use operators in ","只是一个重载过程。解析器让你使用运算符在"),
("infix notation","中缀记号"),
("). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does ",
"）。中缀运算符总是需要两个实参，前缀运算符需要一个。（后缀运行符不可行，因为这有歧义："),
("? It always means ","？它总意味着"),
(", because there are no postfix operators in Nim.)","，因为Nim没有后缀运算符。）"),
("Apart from a few built-in keyword operators such as ","除了一些内置关键字运算符如"),
(", operators always consist of these characters: ","，运算符问题由以下字符组成："),
("User defined operators are allowed. Nothing stops you from defining your own ","用户定义运算符是允许的。没人阻止你定义自己的"),
("operator, but doing so may reduce readability.","运算符，但这么做降低了可读性。"),
("The operator\'s precedence is determined by its first character. The details can be found in the manual. ",
"运算符优先级由第一个字符决定。可以在手册中看到更多细节。"),
("To define a new operator enclose the operator in backticks \"``\":","定义用\"``\"括起来的新运算符："),
("# now the $ operator also works with myDataType, overloading resolution","# 现在$运算符也可以用于myDataType,重载解析"),
("# ensures that $ works for built-in types just like before","# 确保内置类型的$还像之前一样"),
("The \"``\" notation can also be used to call an operator just like any other procedure:","\"``\"记号也可用于调用像其它过程一样的运算符："),
("Every variable, procedure, etc. needs to be declared before it can be used. (The reason for this is that it is non-trivial to avoid this need in a language that supports meta programming as extensively as Nim does.) However, this cannot be done for mutually recursive procedures:",
"每个变量、过程等。需要在使用前声明。（这样做的原因是，使用像Nim一样广泛支持元编程的语言来避免这种需求并非易事。）但是，这对于相互递归的过程是无法做到的："),
("# forward declaration:","# 前向声明"),
("# makes sure we don't run into negative recursion","# 确保我们不进入负递归"),
("Here ","这里"),
("depends on ","取决于"),
("and vice versa. Thus ","反之亦然。因此"),
("needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the ",
"需要在完全定义前引入编译器。每个前向声明的语法很简单：只忽略"),
("and the procedure's body. The ","和过程体。"),
("just adds border conditions, and will be covered later in ","只添加边界条件，将讲解在后续的"),
("Later versions of the language will weaken the requirements for forward declarations.","语言的后续版本将弱化前向声明。"),
("The example also shows that a proc\'s body can consist of a single expression whose value is then returned implicitly.","示例展示过程体由单个表达式组成，其值被隐式地返回。"),
("Let's return to the simple counting example:","让我们回到这个简单的计数示例："),
("Can a ","可不可以用"),
("proc be written that supports this loop? Lets try:","过程支持这个循环？让我们试下："),
("However, this does not work. The problem is that the procedure should not only ","不行。问题在于过程不应当只"),
(", but return and ","而且要"),
("after an iteration has finished. This ","，在一次迭代完成后。这种"),
("return and continue","return并continue"),
("is called a ","叫做"),
("statement. Now the only thing left to do is to replace the ","语句。现在只剩下替换"),
("keyword by ","关键字用"),
("and here it is - our first iterator:","这是我们的第一个迭代器："),
("Iterators look very similar to procedures, but there are several important differences:",
"迭代器看起来很像过程，但有几点重要的区别："),
("Iterators can only be called from for loops.","迭代器只能使用在循环中。"),
("Iterators cannot contain a ","迭代器不能包含"),
("statement (and procs cannot contain a " ,"语句（且procs不能包含"),
("statement). " ,"语句）。"),
("Iterators have no implicit " ,"迭代器没有隐式的"),
("variable. " ,"变量。"),
("Iterators do not support recursion." ,"迭代器不支持递归。"),
("Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)",
"迭代器不能前向声明，因为编译器必须内联迭代器。（这个限制将在未来的编译器版本中消失。）"),
("However, you can also use a " ,"但是你也可以用"),
("iterator to get a different set of restrictions. See " ,"迭代器来获取限制集合。见"),
("first class iterators" ,"一类迭代器"),
("for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like ",
"的更多细节。迭代器可以和proc一样有同样的名字和形参，因为实质上他们拥有自己的命名空间。因此这是一个普遍的实践，即把迭代器封装在同名的proc中，累计迭代器的结果并以序列返回，如"),
("from the " ,"来自"),
("strutils module" ,"strutils模块"),
("This section deals with the basic built-in types and the operations that are available for them in detail." ,
"这部分处理基本的内置类型和它们可用的运算符细节。"),
("Nim's boolean type is called " ,"Nim的布林类型叫做"),
("and consists of the two pre-defined values " ,"分为两个预定义的值"),
(". Conditions in while, if, elif, and when statements must be of type bool." ,"。while,if,elif中的条件语句必须是bool类型。"),
("The operators " ,"运算符"),
("are defined for the bool type. The " ,"为bool类型定义。"),
("operators perform short-circuit evaluation. For example:" ,"运算执行短路求值。例如："),
("# p.name is not evaluated if p == nil" ,"# 如果p == nil, p.name便不求值"),
("character type" ,"字符类型"),
(". Its size is always one byte, so it cannot represent most UTF-8 characters; but it " ,"。它的大小总是1字节，它不能代表多数UTF-8字符；但它"),
("can" ,"可以"),
("represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes." ,
"代表组成多字节UTF-8字符的一个字节。这是出于效率：对绝大多数情况，结果程序仍将正确处理UTF-8，因为UTF-8正是为此而设计的，字符字面值被括在单引号中。"),
("Chars can be compared with the " ,"字符可以比较"),
("operators. The " ,"运算符。"),
("operator converts a " ,"运算符转换"),
("to a " ,"为"),
(". Chars cannot be mixed with integers; to get the ordinal value of a " ,"。字符不能和整数混合；为了得到序数值代表的"),
("use the " ,"使用"),
("proc. Converting from an integer to a " ,"过程。从整数转换为"),
("is done with the " ,"使用"),
("proc." ,"过程。"),
("String variables are " ,"字符串变量是"),
("mutable" ,"可变的"),
(", so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string\'s length can be retrieved with the builtin " ,
"，所以可以追加字符串，并且这很高效。Nim中的字符串即是零结尾，也有一个长度字段。字符串长度获取可以通过内置"),
("procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a " ,
"过程；长度不计结尾的零。访问结尾零是一个错误，它存在只为Nim字符串可以转换成"),
("without doing a copy." ,"，无需拷贝。"),
("The assignment operator for strings copies the string. You can use the " ,"字符串赋值运算符会拷贝。你可以使用"),
("operator to concatenate strings and " ,"运算符拼接字符串，"),
("to append to a string." ,"追加字符串"),
("Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation " ,
"字符串使用词法序比较。支持所有比较运算符。按照惯例，所有字符串都是UTF-8编码，但这不是强制的。例如，当从二进制读取字符串时，他们只是字节序列。索引运算符"),
("means the i-th " ,"表示第i个"),
("char" ,"字符"),
("of " ,"在"),
(", not the i-th " ,"，不是第i个"),
("A string variable is initialized with the empty string " ,"字符串变量用空字符串初始化"),
("Nim has these integer types built-in: " ,"Nim有以下内置整数类型："),
("The default integer type is " ,"默认的整数类型为"),
(". Integer literals can have a " ,"。整数字面值可以有"),
("type suffix" ,"类型后缀"),
("to specify a non-default integer type:" ,"来指定非默认整数类型："),
("# x is of type ``int``" ,"# x属于``int``类型"),
("# y is of type ``int8``" ,"# y属于``int8``类型"),
("# z is of type ``int64``" ,"# z属于``int64``类型"),
("# u is of type ``uint``" ,"# u属于``uint``类型"),
("Most often integers are used for counting objects that reside in memory, so " ,"多数整数用于计算内存中的对象个数，所以"),
("has the same size as a pointer." ,"具有指针的大小。"),
("The common operators " ,"通用运算符"),
("are defined for integers. The " ,"为整数定义。"),
("operators are also defined for integers, and provide " ,"也为整数定义，还提供"),
("bitwise","按位"),
("operations. Left bit shifting is done with the " ,"运算符。左移使用"),
(", right shifting with the " ,"，右移使用"),
("operator. Bit shifting operators always treat their arguments as " ,"运算符。位移运算总是把他们的实参作为"),
("unsigned" ,"无符号"),
(". For " ,"。对于"),
("arithmetic bit shifts" ,"代数位移"),
("ordinary multiplication or division can be used." ,"平常的乘法或除法也可以使用。"),
("Unsigned operations all wrap around; they cannot lead to over- or under-flow errors." ,"所有无符号运算都被封装；它们不会引起上溢或下溢。"),
("Lossless " ,"无损"),
("Automatic type conversion " ,"自动类型转换"),
("is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the " ,
"在表达式中使用不同整数类型时执行。但是如果类型转换会丢失信息，"),
("exception is raised (if the error cannot be detected at compile time)." ,"异常会被发起（如果错误在编译期检测到）。"),

          

]

for i in dict:
  addTranslation(Language.zhCN, i[0],i[1])

